<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_91) on Sat Dec 03 20:19:17 MST 2016 -->
<title>Client (litesockets 2.1.0 API)</title>
<meta name="date" content="2016-12-03">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Client (litesockets 2.1.0 API)";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":6,"i1":6,"i2":6,"i3":6,"i4":6,"i5":6,"i6":6,"i7":6,"i8":6,"i9":6,"i10":6,"i11":6,"i12":6,"i13":6,"i14":6,"i15":6,"i16":6,"i17":6,"i18":6,"i19":6,"i20":6,"i21":6,"i22":6};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev&nbsp;Class</li>
<li><a href="../../../org/threadly/litesockets/Client.Closer.html" title="interface in org.threadly.litesockets"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?org/threadly/litesockets/Client.html" target="_top">Frames</a></li>
<li><a href="Client.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">org.threadly.litesockets</div>
<h2 title="Class Client" class="title">Class Client</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>org.threadly.litesockets.Client</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>Direct Known Subclasses:</dt>
<dd><a href="../../../org/threadly/litesockets/tcp/TCPClient.html" title="class in org.threadly.litesockets.tcp">TCPClient</a>, <a href="../../../org/threadly/litesockets/udp/UDPClient.html" title="class in org.threadly.litesockets.udp">UDPClient</a></dd>
</dl>
<hr>
<br>
<pre>public abstract class <span class="typeNameLabel">Client</span>
extends java.lang.Object</pre>
<div class="block"><p>This is the main Client interface used in litesockets.  Anything that reads or writes data
 will use this object.  The clients work by having buffered reads and writes for the socket. They tell the
 SocketExecuter when a read can be added or a write is ready for the socket.</p>
 
 <p>All reads are issued on a callback on a Reader in a single threaded manor.
 All writes will be sent in the order they are received.  In general its better to write full protocol parsable
 packets with each write where possible.  If not possible your own locking/ordering will have to be ensured.
 Close events will happen on there own Closer callback but it uses the same ThreadKey as the Reader thread.  
 All Reads should be received before a close event happens.</p>
 
 The client object can not function with out being in a SocketExecuter.  Writes can be added before its put
 in the executer, but it will not write to the socket until added to the executer.</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="nested.class.summary">
<!--   -->
</a>
<h3>Nested Class Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Nested Class Summary table, listing nested classes, and an explanation">
<caption><span>Nested Classes</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Class and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static interface&nbsp;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/threadly/litesockets/Client.Closer.html" title="interface in org.threadly.litesockets">Client.Closer</a></span></code>
<div class="block">This is the Closer Interface for clients.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static interface&nbsp;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/threadly/litesockets/Client.Reader.html" title="interface in org.threadly.litesockets">Client.Reader</a></span></code>
<div class="block">This is the Reader Interface for clients.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../../org/threadly/litesockets/Client.html#Client--">Client</a></span>()</code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t3" class="tableTab"><span><a href="javascript:show(4);">Abstract Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>abstract void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/threadly/litesockets/Client.html#close--">close</a></span>()</code>
<div class="block">Closes this client.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>abstract org.threadly.concurrent.future.ListenableFuture&lt;java.lang.Boolean&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/threadly/litesockets/Client.html#connect--">connect</a></span>()</code>
<div class="block">Called to connect this client to a host.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>abstract <a href="../../../org/threadly/litesockets/SocketExecuterInterface.html" title="interface in org.threadly.litesockets">SocketExecuterInterface</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/threadly/litesockets/Client.html#getClientsSocketExecuter--">getClientsSocketExecuter</a></span>()</code>
<div class="block">This is used to get the clients currently assigned <a href="../../../org/threadly/litesockets/SocketExecuterInterface.html" title="interface in org.threadly.litesockets"><code>SocketExecuterInterface</code></a>.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>abstract java.util.concurrent.Executor</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/threadly/litesockets/Client.html#getClientsThreadExecutor--">getClientsThreadExecutor</a></span>()</code>
<div class="block"> This returns this clients <code>Executor</code>.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>abstract <a href="../../../org/threadly/litesockets/Client.Closer.html" title="interface in org.threadly.litesockets">Client.Closer</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/threadly/litesockets/Client.html#getCloser--">getCloser</a></span>()</code>
<div class="block">This is used to get the currently set <a href="../../../org/threadly/litesockets/Client.Closer.html" title="interface in org.threadly.litesockets"><code>Client.Closer</code></a> for this client.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>abstract java.net.SocketAddress</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/threadly/litesockets/Client.html#getLocalSocketAddress--">getLocalSocketAddress</a></span>()</code>&nbsp;</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>abstract int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/threadly/litesockets/Client.html#getMaxBufferSize--">getMaxBufferSize</a></span>()</code>
<div class="block">This is used to get the currently set max buffer size.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>abstract <a href="../../../org/threadly/litesockets/SocketExecuterInterface.WireProtocol.html" title="enum in org.threadly.litesockets">SocketExecuterInterface.WireProtocol</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/threadly/litesockets/Client.html#getProtocol--">getProtocol</a></span>()</code>
<div class="block">This is used by the <a href="../../../org/threadly/litesockets/SocketExecuterInterface.html" title="interface in org.threadly.litesockets"><code>SocketExecuterInterface</code></a> to help understand how to manage this client.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>abstract <a href="../../../org/threadly/litesockets/utils/MergedByteBuffers.html" title="class in org.threadly.litesockets.utils">MergedByteBuffers</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/threadly/litesockets/Client.html#getRead--">getRead</a></span>()</code>
<div class="block">Whenever a the <a href="../../../org/threadly/litesockets/Client.Reader.html" title="interface in org.threadly.litesockets"><code>Client.Reader</code></a> Interfaces <a href="../../../org/threadly/litesockets/Client.Reader.html#onRead-org.threadly.litesockets.Client-"><code>Client.Reader.onRead(Client)</code></a> is called the
 <a href="../../../org/threadly/litesockets/Client.html#getRead--"><code>getRead()</code></a> should be called from the client.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>abstract int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/threadly/litesockets/Client.html#getReadBufferSize--">getReadBufferSize</a></span>()</code>
<div class="block">This is used to get the current size of the readBuffers pending reads.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>abstract <a href="../../../org/threadly/litesockets/Client.Reader.html" title="interface in org.threadly.litesockets">Client.Reader</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/threadly/litesockets/Client.html#getReader--">getReader</a></span>()</code>
<div class="block">Returns the currently set Reader callback.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>abstract java.net.SocketAddress</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/threadly/litesockets/Client.html#getRemoteSocketAddress--">getRemoteSocketAddress</a></span>()</code>&nbsp;</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>abstract <a href="../../../org/threadly/litesockets/utils/SimpleByteStats.html" title="class in org.threadly.litesockets.utils">SimpleByteStats</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/threadly/litesockets/Client.html#getStats--">getStats</a></span>()</code>
<div class="block">Returns the <a href="../../../org/threadly/litesockets/utils/SimpleByteStats.html" title="class in org.threadly.litesockets.utils"><code>SimpleByteStats</code></a> for this client.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>abstract int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/threadly/litesockets/Client.html#getTimeout--">getTimeout</a></span>()</code>
<div class="block">Used to get this clients connection timeout information.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>abstract int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/threadly/litesockets/Client.html#getWriteBufferSize--">getWriteBufferSize</a></span>()</code>
<div class="block">This is used to get the current size of the unWriten writeBuffer.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>abstract boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/threadly/litesockets/Client.html#hasConnectionTimedOut--">hasConnectionTimedOut</a></span>()</code>
<div class="block">This tells us if the client has timed out before it has been connected to the socket.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>abstract boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/threadly/litesockets/Client.html#isClosed--">isClosed</a></span>()</code>
<div class="block">Returns if this client is closed or not.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>abstract void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/threadly/litesockets/Client.html#setCloser-org.threadly.litesockets.Client.Closer-">setCloser</a></span>(<a href="../../../org/threadly/litesockets/Client.Closer.html" title="interface in org.threadly.litesockets">Client.Closer</a>&nbsp;closer)</code>
<div class="block">This sets the <a href="../../../org/threadly/litesockets/Client.Closer.html" title="interface in org.threadly.litesockets"><code>Client.Closer</code></a> interface for this client.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>abstract void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/threadly/litesockets/Client.html#setMaxBufferSize-int-">setMaxBufferSize</a></span>(int&nbsp;size)</code>
<div class="block">This allows you to set/change the max buffer size for this client object.</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>abstract void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/threadly/litesockets/Client.html#setReader-org.threadly.litesockets.Client.Reader-">setReader</a></span>(<a href="../../../org/threadly/litesockets/Client.Reader.html" title="interface in org.threadly.litesockets">Client.Reader</a>&nbsp;reader)</code>
<div class="block">This sets the Reader for the client.This should be set before adding the Client to the <a href="../../../org/threadly/litesockets/SocketExecuterInterface.html" title="interface in org.threadly.litesockets"><code>SocketExecuterInterface</code></a>, 
 if its not there is a chance to miss data coming in on the socket.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>abstract void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/threadly/litesockets/Client.html#writeBlocking-java.nio.ByteBuffer-">writeBlocking</a></span>(java.nio.ByteBuffer&nbsp;bb)</code>
<div class="block">This write will block until the write can be done.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>abstract void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/threadly/litesockets/Client.html#writeForce-java.nio.ByteBuffer-">writeForce</a></span>(java.nio.ByteBuffer&nbsp;bb)</code>
<div class="block">This write forces the client to go over its maxBufferSize.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>abstract boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/threadly/litesockets/Client.html#writeTry-java.nio.ByteBuffer-">writeTry</a></span>(java.nio.ByteBuffer&nbsp;bb)</code>
<div class="block"> This tries to write the ByteBuffer passed to it to the Client.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="Client--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>Client</h4>
<pre>public&nbsp;Client()</pre>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="hasConnectionTimedOut--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasConnectionTimedOut</h4>
<pre>public abstract&nbsp;boolean&nbsp;hasConnectionTimedOut()</pre>
<div class="block"><p>This tells us if the client has timed out before it has been connected to the socket.  This is used to remove the client
 from the selector when we have reached our timeout.  With nio there is no way to have it automatically 
 wake up the selector and time it out.  If the client has connected fully this will return false from that point on 
 (even on a closed connection).</p></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>false if the client has been connected, true if it has not connected and the timeout limit has been reached.</dd>
</dl>
</li>
</ul>
<a name="connect--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>connect</h4>
<pre>public abstract&nbsp;org.threadly.concurrent.future.ListenableFuture&lt;java.lang.Boolean&gt;&nbsp;connect()</pre>
<div class="block"><p>Called to connect this client to a host.  This is done non-blocking, and can be called before adding the client 
 to the <a href="../../../org/threadly/litesockets/SocketExecuterInterface.html" title="interface in org.threadly.litesockets"><code>SocketExecuterInterface</code></a>, but the client must be on the <a href="../../../org/threadly/litesockets/SocketExecuterInterface.html" title="interface in org.threadly.litesockets"><code>SocketExecuterInterface</code></a> 
 in order to finish connecting.  If not called <a href="../../../org/threadly/litesockets/SocketExecuterInterface.html#addClient-org.threadly.litesockets.Client-"><code>SocketExecuterInterface.addClient(Client)</code></a>
 will automatically call this.</p>
 
 <p>If there is an error connecting <a href="../../../org/threadly/litesockets/Client.html#close--"><code>close()</code></a> will also be called on the client.</p></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <code>ListenableFuture</code> that will complete when the socket is connected, or fail if we cant connect.</dd>
</dl>
</li>
</ul>
<a name="getTimeout--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getTimeout</h4>
<pre>public abstract&nbsp;int&nbsp;getTimeout()</pre>
<div class="block"><p>Used to get this clients connection timeout information.</p></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the max amount of time to wait for a connection to connect on this socket.</dd>
</dl>
</li>
</ul>
<a name="getReadBufferSize--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getReadBufferSize</h4>
<pre>public abstract&nbsp;int&nbsp;getReadBufferSize()</pre>
<div class="block"><p>This is used to get the current size of the readBuffers pending reads.</p></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the current size of the ReadBuffer.</dd>
</dl>
</li>
</ul>
<a name="getWriteBufferSize--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getWriteBufferSize</h4>
<pre>public abstract&nbsp;int&nbsp;getWriteBufferSize()</pre>
<div class="block"><p>This is used to get the current size of the unWriten writeBuffer.</p></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the current size of the writeBuffer.</dd>
</dl>
</li>
</ul>
<a name="getMaxBufferSize--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMaxBufferSize</h4>
<pre>public abstract&nbsp;int&nbsp;getMaxBufferSize()</pre>
<div class="block">This is used to get the currently set max buffer size.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the current MaxBuffer size allowed.  The read and write buffer use this independently.</dd>
</dl>
</li>
</ul>
<a name="getClientsThreadExecutor--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getClientsThreadExecutor</h4>
<pre>public abstract&nbsp;java.util.concurrent.Executor&nbsp;getClientsThreadExecutor()</pre>
<div class="block"><p> This returns this clients <code>Executor</code>.  The client must have been added to the <a href="../../../org/threadly/litesockets/SocketExecuterInterface.html" title="interface in org.threadly.litesockets"><code>SocketExecuterInterface</code></a> or 
 this will return null.</p>
 
 <p> Its worth noting that operations done on this <code>Executor</code> can/will block Read callbacks on the 
 client, but it does provide you the ability to execute things on the clients read thread</p></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The <code>Executor</code> for the client.</dd>
</dl>
</li>
</ul>
<a name="getClientsSocketExecuter--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getClientsSocketExecuter</h4>
<pre>public abstract&nbsp;<a href="../../../org/threadly/litesockets/SocketExecuterInterface.html" title="interface in org.threadly.litesockets">SocketExecuterInterface</a>&nbsp;getClientsSocketExecuter()</pre>
<div class="block"><p>This is used to get the clients currently assigned <a href="../../../org/threadly/litesockets/SocketExecuterInterface.html" title="interface in org.threadly.litesockets"><code>SocketExecuterInterface</code></a>.</p></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the <a href="../../../org/threadly/litesockets/SocketExecuterInterface.html" title="interface in org.threadly.litesockets"><code>SocketExecuterInterface</code></a> set for this client. if none, null is returned.</dd>
</dl>
</li>
</ul>
<a name="getCloser--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getCloser</h4>
<pre>public abstract&nbsp;<a href="../../../org/threadly/litesockets/Client.Closer.html" title="interface in org.threadly.litesockets">Client.Closer</a>&nbsp;getCloser()</pre>
<div class="block"><p>This is used to get the currently set <a href="../../../org/threadly/litesockets/Client.Closer.html" title="interface in org.threadly.litesockets"><code>Client.Closer</code></a> for this client.</p></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the current <a href="../../../org/threadly/litesockets/Client.Closer.html" title="interface in org.threadly.litesockets"><code>Client.Closer</code></a> interface for this client.</dd>
</dl>
</li>
</ul>
<a name="setCloser-org.threadly.litesockets.Client.Closer-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setCloser</h4>
<pre>public abstract&nbsp;void&nbsp;setCloser(<a href="../../../org/threadly/litesockets/Client.Closer.html" title="interface in org.threadly.litesockets">Client.Closer</a>&nbsp;closer)</pre>
<div class="block"><p>This sets the <a href="../../../org/threadly/litesockets/Client.Closer.html" title="interface in org.threadly.litesockets"><code>Client.Closer</code></a> interface for this client.  Once set the client will call .onClose 
 on it once it a socket close is detected.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>closer</code> - sets this clients <a href="../../../org/threadly/litesockets/Client.Closer.html" title="interface in org.threadly.litesockets"><code>Client.Closer</code></a> callback.</dd>
</dl>
</li>
</ul>
<a name="getReader--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getReader</h4>
<pre>public abstract&nbsp;<a href="../../../org/threadly/litesockets/Client.Reader.html" title="interface in org.threadly.litesockets">Client.Reader</a>&nbsp;getReader()</pre>
<div class="block"><p>Returns the currently set Reader callback. </p></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the current <a href="../../../org/threadly/litesockets/Client.Reader.html" title="interface in org.threadly.litesockets"><code>Client.Reader</code></a> callback for this client.</dd>
</dl>
</li>
</ul>
<a name="setReader-org.threadly.litesockets.Client.Reader-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setReader</h4>
<pre>public abstract&nbsp;void&nbsp;setReader(<a href="../../../org/threadly/litesockets/Client.Reader.html" title="interface in org.threadly.litesockets">Client.Reader</a>&nbsp;reader)</pre>
<div class="block"><p>This sets the Reader for the client.This should be set before adding the Client to the <a href="../../../org/threadly/litesockets/SocketExecuterInterface.html" title="interface in org.threadly.litesockets"><code>SocketExecuterInterface</code></a>, 
 if its not there is a chance to miss data coming in on the socket.  Once set data received on the socket will be callback 
 on this Reader to be processed.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>reader</code> - the <a href="../../../org/threadly/litesockets/Client.Reader.html" title="interface in org.threadly.litesockets"><code>Client.Reader</code></a> callback to set for this client.</dd>
</dl>
</li>
</ul>
<a name="setMaxBufferSize-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setMaxBufferSize</h4>
<pre>public abstract&nbsp;void&nbsp;setMaxBufferSize(int&nbsp;size)</pre>
<div class="block"><p>This allows you to set/change the max buffer size for this client object.
 This is the in java memory buffer not the additional socket buffer the OS might setup.</p>
 
 <p>In general this should be set to the max size you can deal with.  The lower this is the more often we
 will end up adding/removing the client from the selectors.  Both the read and write buffers are separate so 
 a client can use up to 2x the buffer size set here.  You need room in your heap for buffers for all clients.
 These buffers are not kept at full size, so clients will rarely use that much memory if the protocol parsing 
 and network are keeping up with the data going in/out.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>size</code> - max buffer size in bytes.</dd>
</dl>
</li>
</ul>
<a name="getRead--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRead</h4>
<pre>public abstract&nbsp;<a href="../../../org/threadly/litesockets/utils/MergedByteBuffers.html" title="class in org.threadly.litesockets.utils">MergedByteBuffers</a>&nbsp;getRead()</pre>
<div class="block"><p>Whenever a the <a href="../../../org/threadly/litesockets/Client.Reader.html" title="interface in org.threadly.litesockets"><code>Client.Reader</code></a> Interfaces <a href="../../../org/threadly/litesockets/Client.Reader.html#onRead-org.threadly.litesockets.Client-"><code>Client.Reader.onRead(Client)</code></a> is called the
 <a href="../../../org/threadly/litesockets/Client.html#getRead--"><code>getRead()</code></a> should be called from the client.</p></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="../../../org/threadly/litesockets/utils/MergedByteBuffers.html" title="class in org.threadly.litesockets.utils"><code>MergedByteBuffers</code></a> of the current read data for this client.</dd>
</dl>
</li>
</ul>
<a name="writeTry-java.nio.ByteBuffer-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>writeTry</h4>
<pre>public abstract&nbsp;boolean&nbsp;writeTry(java.nio.ByteBuffer&nbsp;bb)</pre>
<div class="block"><p> This tries to write the ByteBuffer passed to it to the Client.  If the Clients writeBuffer 
 is greater than the maxbufferSize the <code>ByteBuffer</code> will not be added and false will be returned.
 If the current writeBuffer is less than the maxBufferSize then the ByteBuffer will be added and this
 will return true.</p>
 
 <p>As this write is thread safe it should be noted that calling this with multiThreads can not garentee order.
 As such it is recommended to write full parsable protocol packets at a time, or implement your own locking around the
 write if you are streaming data raw data and using more then 1 thread to do such.
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>bb</code> - the <code>ByteBuffer</code> to write to the client.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>true if the client has taken the ByteBuffer false if it did not.</dd>
</dl>
</li>
</ul>
<a name="writeBlocking-java.nio.ByteBuffer-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>writeBlocking</h4>
<pre>public abstract&nbsp;void&nbsp;writeBlocking(java.nio.ByteBuffer&nbsp;bb)
                            throws java.lang.InterruptedException</pre>
<div class="block"><p>This write will block until the write can be done.  This block will only happen if the clients
 current writeBuffer size is more than the set maxBuffer.  This block will persist either until
 the clients writeBuffer is less than the maxWriteBuffer or the client is closed.</p>
 
 <p>Care should be taken when using this.  The pending writes for the client will happen on another unblockable 
 thread but if a lot of clients use there read thread to write and block its possible to consume all threads
 in the pool.  This is only a problem if the thread pool is reading/writing from both sides of a client connection
 using the same thread pool.</p>
 
 <p>As this write is thread safe it should be noted that calling this with multiThreads can not garentee order.
 As such it is recommended to write full parsable protocol packets at a time, or implement your own locking around the
 write if you are streaming data raw data and using more then 1 thread to do such.
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>bb</code> - the <code>ByteBuffer</code> to write.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.InterruptedException</code> - This happens only if the thread that is blocked is interrupted while waiting.</dd>
</dl>
</li>
</ul>
<a name="writeForce-java.nio.ByteBuffer-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>writeForce</h4>
<pre>public abstract&nbsp;void&nbsp;writeForce(java.nio.ByteBuffer&nbsp;bb)</pre>
<div class="block"><p>This write forces the client to go over its maxBufferSize.  This can be dangerous if used incorrectly.
 Its assumed if this is used you are keeping track of the clients writeBuffer on your own.</p>
 
 <p>As this write is thread safe it should be noted that calling this with multiThreads can not garentee order.
 As such it is recommended to write full parsable protocol packets at a time, or implement your own locking around the
 write if you are streaming data raw data and using more then 1 thread to do such.
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>bb</code> - the ByteBuffer to write to the client.</dd>
</dl>
</li>
</ul>
<a name="getProtocol--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getProtocol</h4>
<pre>public abstract&nbsp;<a href="../../../org/threadly/litesockets/SocketExecuterInterface.WireProtocol.html" title="enum in org.threadly.litesockets">SocketExecuterInterface.WireProtocol</a>&nbsp;getProtocol()</pre>
<div class="block"><p>This is used by the <a href="../../../org/threadly/litesockets/SocketExecuterInterface.html" title="interface in org.threadly.litesockets"><code>SocketExecuterInterface</code></a> to help understand how to manage this client.
 Currently only UDP and TCP exist.</p></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The IP protocol type of this client.</dd>
</dl>
</li>
</ul>
<a name="isClosed--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isClosed</h4>
<pre>public abstract&nbsp;boolean&nbsp;isClosed()</pre>
<div class="block"><p>Returns if this client is closed or not.  Once a client is marked closed there is no way to reOpen it.
 You must just make a new client.  Just because this returns false does not mean the client is connected.
 Before a client connects, but has not yet closed this will be false.</p></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>true if the client is closed, false if the client has not yet been closed.</dd>
</dl>
</li>
</ul>
<a name="close--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>close</h4>
<pre>public abstract&nbsp;void&nbsp;close()</pre>
<div class="block"><p>Closes this client.  Reads can still occur after this it called.  <a href="../../../org/threadly/litesockets/Client.Closer.html#onClose-org.threadly.litesockets.Client-"><code>Client.Closer.onClose(Client)</code></a> will still be
 called (if set) once all reads are done.</p></div>
</li>
</ul>
<a name="getRemoteSocketAddress--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRemoteSocketAddress</h4>
<pre>public abstract&nbsp;java.net.SocketAddress&nbsp;getRemoteSocketAddress()</pre>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the remote <code>SocketAddress</code> this client is connected to.</dd>
</dl>
</li>
</ul>
<a name="getLocalSocketAddress--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLocalSocketAddress</h4>
<pre>public abstract&nbsp;java.net.SocketAddress&nbsp;getLocalSocketAddress()</pre>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the local <code>SocketAddress</code> this client is using.</dd>
</dl>
</li>
</ul>
<a name="getStats--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>getStats</h4>
<pre>public abstract&nbsp;<a href="../../../org/threadly/litesockets/utils/SimpleByteStats.html" title="class in org.threadly.litesockets.utils">SimpleByteStats</a>&nbsp;getStats()</pre>
<div class="block">Returns the <a href="../../../org/threadly/litesockets/utils/SimpleByteStats.html" title="class in org.threadly.litesockets.utils"><code>SimpleByteStats</code></a> for this client.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the byte stats for this client.</dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev&nbsp;Class</li>
<li><a href="../../../org/threadly/litesockets/Client.Closer.html" title="interface in org.threadly.litesockets"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?org/threadly/litesockets/Client.html" target="_top">Frames</a></li>
<li><a href="Client.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
