<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_91) on Sat Dec 03 20:19:17 MST 2016 -->
<title>TCPClient (litesockets 2.1.0 API)</title>
<meta name="date" content="2016-12-03">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="TCPClient (litesockets 2.1.0 API)";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10,"i13":10,"i14":10,"i15":10,"i16":10,"i17":10,"i18":10,"i19":10,"i20":10,"i21":10,"i22":10,"i23":10};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../org/threadly/litesockets/tcp/SSLUtils.FullTrustManager.html" title="class in org.threadly.litesockets.tcp"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../../org/threadly/litesockets/tcp/TCPServer.html" title="class in org.threadly.litesockets.tcp"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?org/threadly/litesockets/tcp/TCPClient.html" target="_top">Frames</a></li>
<li><a href="TCPClient.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.classes.inherited.from.class.org.threadly.litesockets.Client">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">org.threadly.litesockets.tcp</div>
<h2 title="Class TCPClient" class="title">Class TCPClient</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li><a href="../../../../org/threadly/litesockets/Client.html" title="class in org.threadly.litesockets">org.threadly.litesockets.Client</a></li>
<li>
<ul class="inheritance">
<li>org.threadly.litesockets.tcp.TCPClient</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>Direct Known Subclasses:</dt>
<dd><a href="../../../../org/threadly/litesockets/tcp/SSLClient.html" title="class in org.threadly.litesockets.tcp">SSLClient</a></dd>
</dl>
<hr>
<br>
<pre>public class <span class="typeNameLabel">TCPClient</span>
extends <a href="../../../../org/threadly/litesockets/Client.html" title="class in org.threadly.litesockets">Client</a></pre>
<div class="block">This is a generic Client for TCP connections.  This client can be either from the "client" side or
 from a client from a <a href="../../../../org/threadly/litesockets/tcp/TCPServer.html" title="class in org.threadly.litesockets.tcp"><code>TCPServer</code></a>, and both function the same way.</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="nested.class.summary">
<!--   -->
</a>
<h3>Nested Class Summary</h3>
<ul class="blockList">
<li class="blockList"><a name="nested.classes.inherited.from.class.org.threadly.litesockets.Client">
<!--   -->
</a>
<h3>Nested classes/interfaces inherited from class&nbsp;org.threadly.litesockets.<a href="../../../../org/threadly/litesockets/Client.html" title="class in org.threadly.litesockets">Client</a></h3>
<code><a href="../../../../org/threadly/litesockets/Client.Closer.html" title="interface in org.threadly.litesockets">Client.Closer</a>, <a href="../../../../org/threadly/litesockets/Client.Reader.html" title="interface in org.threadly.litesockets">Client.Reader</a></code></li>
</ul>
</li>
</ul>
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/threadly/litesockets/tcp/TCPClient.html#DEFAULT_MAX_BUFFER_SIZE">DEFAULT_MAX_BUFFER_SIZE</a></span></code>
<div class="block">Default max buffer size (64k).</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/threadly/litesockets/tcp/TCPClient.html#DEFAULT_SOCKET_TIMEOUT">DEFAULT_SOCKET_TIMEOUT</a></span></code>
<div class="block">The default SocketConnection time out (10 seconds).</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/threadly/litesockets/tcp/TCPClient.html#MAX_COMBINED_WRITE_BUFFER_SIZE">MAX_COMBINED_WRITE_BUFFER_SIZE</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/threadly/litesockets/tcp/TCPClient.html#MIN_READ_BUFFER_SIZE">MIN_READ_BUFFER_SIZE</a></span></code>
<div class="block">Minimum allowed readBuffer (4k).</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/threadly/litesockets/tcp/TCPClient.html#MIN_WRITE_BUFFER_SIZE">MIN_WRITE_BUFFER_SIZE</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/threadly/litesockets/tcp/TCPClient.html#NEW_READ_BUFFER_SIZE">NEW_READ_BUFFER_SIZE</a></span></code>
<div class="block">When we hit the minimum read buffer size we will create a new one of this size (64k).</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../../../org/threadly/litesockets/tcp/TCPClient.html#TCPClient-java.nio.channels.SocketChannel-">TCPClient</a></span>(java.nio.channels.SocketChannel&nbsp;channel)</code>
<div class="block">This creates a TCPClient based off an already existing <code>SocketChannel</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../../../org/threadly/litesockets/tcp/TCPClient.html#TCPClient-java.lang.String-int-">TCPClient</a></span>(java.lang.String&nbsp;host,
         int&nbsp;port)</code>
<div class="block">This creates a connection to the specified port and IP.</div>
</td>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../../../org/threadly/litesockets/tcp/TCPClient.html#TCPClient-java.lang.String-int-int-">TCPClient</a></span>(java.lang.String&nbsp;host,
         int&nbsp;port,
         int&nbsp;timeout)</code>
<div class="block">This creates TCPClient with a connection to the specified port and IP.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/threadly/litesockets/tcp/TCPClient.html#close--">close</a></span>()</code>
<div class="block">Closes this client.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>org.threadly.concurrent.future.ListenableFuture&lt;java.lang.Boolean&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/threadly/litesockets/tcp/TCPClient.html#connect--">connect</a></span>()</code>
<div class="block">Called to connect this client to a host.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code><a href="../../../../org/threadly/litesockets/SocketExecuterInterface.html" title="interface in org.threadly.litesockets">SocketExecuterInterface</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/threadly/litesockets/tcp/TCPClient.html#getClientsSocketExecuter--">getClientsSocketExecuter</a></span>()</code>
<div class="block">This is used to get the clients currently assigned <a href="../../../../org/threadly/litesockets/SocketExecuterInterface.html" title="interface in org.threadly.litesockets"><code>SocketExecuterInterface</code></a>.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>java.util.concurrent.Executor</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/threadly/litesockets/tcp/TCPClient.html#getClientsThreadExecutor--">getClientsThreadExecutor</a></span>()</code>
<div class="block"> This returns this clients <code>Executor</code>.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code><a href="../../../../org/threadly/litesockets/Client.Closer.html" title="interface in org.threadly.litesockets">Client.Closer</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/threadly/litesockets/tcp/TCPClient.html#getCloser--">getCloser</a></span>()</code>
<div class="block">This is used to get the currently set <a href="../../../../org/threadly/litesockets/Client.Closer.html" title="interface in org.threadly.litesockets"><code>Client.Closer</code></a> for this client.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>java.net.SocketAddress</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/threadly/litesockets/tcp/TCPClient.html#getLocalSocketAddress--">getLocalSocketAddress</a></span>()</code>&nbsp;</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/threadly/litesockets/tcp/TCPClient.html#getMaxBufferSize--">getMaxBufferSize</a></span>()</code>
<div class="block">This is used to get the currently set max buffer size.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code><a href="../../../../org/threadly/litesockets/SocketExecuterInterface.WireProtocol.html" title="enum in org.threadly.litesockets">SocketExecuterInterface.WireProtocol</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/threadly/litesockets/tcp/TCPClient.html#getProtocol--">getProtocol</a></span>()</code>
<div class="block">This is used by the <a href="../../../../org/threadly/litesockets/SocketExecuterInterface.html" title="interface in org.threadly.litesockets"><code>SocketExecuterInterface</code></a> to help understand how to manage this client.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code><a href="../../../../org/threadly/litesockets/utils/MergedByteBuffers.html" title="class in org.threadly.litesockets.utils">MergedByteBuffers</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/threadly/litesockets/tcp/TCPClient.html#getRead--">getRead</a></span>()</code>
<div class="block">Whenever a the <a href="../../../../org/threadly/litesockets/Client.Reader.html" title="interface in org.threadly.litesockets"><code>Client.Reader</code></a> Interfaces <a href="../../../../org/threadly/litesockets/Client.Reader.html#onRead-org.threadly.litesockets.Client-"><code>Client.Reader.onRead(Client)</code></a> is called the
 <a href="../../../../org/threadly/litesockets/Client.html#getRead--"><code>Client.getRead()</code></a> should be called from the client.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/threadly/litesockets/tcp/TCPClient.html#getReadBufferSize--">getReadBufferSize</a></span>()</code>
<div class="block">This is used to get the current size of the readBuffers pending reads.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code><a href="../../../../org/threadly/litesockets/Client.Reader.html" title="interface in org.threadly.litesockets">Client.Reader</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/threadly/litesockets/tcp/TCPClient.html#getReader--">getReader</a></span>()</code>
<div class="block">Returns the currently set Reader callback.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>java.net.SocketAddress</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/threadly/litesockets/tcp/TCPClient.html#getRemoteSocketAddress--">getRemoteSocketAddress</a></span>()</code>&nbsp;</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code><a href="../../../../org/threadly/litesockets/utils/SimpleByteStats.html" title="class in org.threadly.litesockets.utils">SimpleByteStats</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/threadly/litesockets/tcp/TCPClient.html#getStats--">getStats</a></span>()</code>
<div class="block">Returns the <a href="../../../../org/threadly/litesockets/utils/SimpleByteStats.html" title="class in org.threadly.litesockets.utils"><code>SimpleByteStats</code></a> for this client.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/threadly/litesockets/tcp/TCPClient.html#getTimeout--">getTimeout</a></span>()</code>
<div class="block">Used to get this clients connection timeout information.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/threadly/litesockets/tcp/TCPClient.html#getWriteBufferSize--">getWriteBufferSize</a></span>()</code>
<div class="block">This is used to get the current size of the unWriten writeBuffer.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/threadly/litesockets/tcp/TCPClient.html#hasConnectionTimedOut--">hasConnectionTimedOut</a></span>()</code>
<div class="block">This tells us if the client has timed out before it has been connected to the socket.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/threadly/litesockets/tcp/TCPClient.html#isClosed--">isClosed</a></span>()</code>
<div class="block">Returns if this client is closed or not.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/threadly/litesockets/tcp/TCPClient.html#setCloser-org.threadly.litesockets.Client.Closer-">setCloser</a></span>(<a href="../../../../org/threadly/litesockets/Client.Closer.html" title="interface in org.threadly.litesockets">Client.Closer</a>&nbsp;closer)</code>
<div class="block">This sets the <a href="../../../../org/threadly/litesockets/Client.Closer.html" title="interface in org.threadly.litesockets"><code>Client.Closer</code></a> interface for this client.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/threadly/litesockets/tcp/TCPClient.html#setMaxBufferSize-int-">setMaxBufferSize</a></span>(int&nbsp;size)</code>
<div class="block">This allows you to set/change the max buffer size for this client object.</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/threadly/litesockets/tcp/TCPClient.html#setReader-org.threadly.litesockets.Client.Reader-">setReader</a></span>(<a href="../../../../org/threadly/litesockets/Client.Reader.html" title="interface in org.threadly.litesockets">Client.Reader</a>&nbsp;reader)</code>
<div class="block">This sets the Reader for the client.This should be set before adding the Client to the <a href="../../../../org/threadly/litesockets/SocketExecuterInterface.html" title="interface in org.threadly.litesockets"><code>SocketExecuterInterface</code></a>, 
 if its not there is a chance to miss data coming in on the socket.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/threadly/litesockets/tcp/TCPClient.html#toString--">toString</a></span>()</code>&nbsp;</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/threadly/litesockets/tcp/TCPClient.html#writeBlocking-java.nio.ByteBuffer-">writeBlocking</a></span>(java.nio.ByteBuffer&nbsp;bb)</code>
<div class="block">This write will block until the write can be done.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/threadly/litesockets/tcp/TCPClient.html#writeForce-java.nio.ByteBuffer-">writeForce</a></span>(java.nio.ByteBuffer&nbsp;bb)</code>
<div class="block">This write forces the client to go over its maxBufferSize.</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/threadly/litesockets/tcp/TCPClient.html#writeTry-java.nio.ByteBuffer-">writeTry</a></span>(java.nio.ByteBuffer&nbsp;bb)</code>
<div class="block"> This tries to write the ByteBuffer passed to it to the Client.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>equals, getClass, hashCode, notify, notifyAll, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a name="DEFAULT_SOCKET_TIMEOUT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DEFAULT_SOCKET_TIMEOUT</h4>
<pre>public static final&nbsp;int DEFAULT_SOCKET_TIMEOUT</pre>
<div class="block">The default SocketConnection time out (10 seconds).</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../constant-values.html#org.threadly.litesockets.tcp.TCPClient.DEFAULT_SOCKET_TIMEOUT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="DEFAULT_MAX_BUFFER_SIZE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DEFAULT_MAX_BUFFER_SIZE</h4>
<pre>public static final&nbsp;int DEFAULT_MAX_BUFFER_SIZE</pre>
<div class="block">Default max buffer size (64k).  Read and write buffers are independent of each other.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../constant-values.html#org.threadly.litesockets.tcp.TCPClient.DEFAULT_MAX_BUFFER_SIZE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="MIN_READ_BUFFER_SIZE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>MIN_READ_BUFFER_SIZE</h4>
<pre>public static final&nbsp;int MIN_READ_BUFFER_SIZE</pre>
<div class="block">Minimum allowed readBuffer (4k).  If the readBuffer is lower then this we will create a new one.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../constant-values.html#org.threadly.litesockets.tcp.TCPClient.MIN_READ_BUFFER_SIZE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="NEW_READ_BUFFER_SIZE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>NEW_READ_BUFFER_SIZE</h4>
<pre>public static final&nbsp;int NEW_READ_BUFFER_SIZE</pre>
<div class="block">When we hit the minimum read buffer size we will create a new one of this size (64k).</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../constant-values.html#org.threadly.litesockets.tcp.TCPClient.NEW_READ_BUFFER_SIZE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="MIN_WRITE_BUFFER_SIZE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>MIN_WRITE_BUFFER_SIZE</h4>
<pre>public static final&nbsp;int MIN_WRITE_BUFFER_SIZE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../constant-values.html#org.threadly.litesockets.tcp.TCPClient.MIN_WRITE_BUFFER_SIZE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="MAX_COMBINED_WRITE_BUFFER_SIZE">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>MAX_COMBINED_WRITE_BUFFER_SIZE</h4>
<pre>public static final&nbsp;int MAX_COMBINED_WRITE_BUFFER_SIZE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../constant-values.html#org.threadly.litesockets.tcp.TCPClient.MAX_COMBINED_WRITE_BUFFER_SIZE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
</li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="TCPClient-java.lang.String-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>TCPClient</h4>
<pre>public&nbsp;TCPClient(java.lang.String&nbsp;host,
                 int&nbsp;port)</pre>
<div class="block">This creates a connection to the specified port and IP.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>host</code> - hostname or ip address to connect too.</dd>
<dd><code>port</code> - port on that host to try and connect too.</dd>
</dl>
</li>
</ul>
<a name="TCPClient-java.lang.String-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>TCPClient</h4>
<pre>public&nbsp;TCPClient(java.lang.String&nbsp;host,
                 int&nbsp;port,
                 int&nbsp;timeout)</pre>
<div class="block">This creates TCPClient with a connection to the specified port and IP.  This connection is not is not
 yet made <a href="../../../../org/threadly/litesockets/tcp/TCPClient.html#connect--"><code>connect()</code></a> must be called, or the client can be added to a <a href="../../../../org/threadly/litesockets/SocketExecuterInterface.html" title="interface in org.threadly.litesockets"><code>SocketExecuterInterface</code></a> with 
 <a href="../../../../org/threadly/litesockets/SocketExecuterInterface.html#addClient-org.threadly.litesockets.Client-"><code>SocketExecuterInterface.addClient(Client)</code></a> which will do the connect.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>host</code> - hostname or ip address to connect too.</dd>
<dd><code>port</code> - port on that host to try and connect too.</dd>
<dd><code>timeout</code> - this is the max amount of time we will wait for a connection to be made.  The default is 10000 milliseconds (10 seconds).</dd>
</dl>
</li>
</ul>
<a name="TCPClient-java.nio.channels.SocketChannel-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>TCPClient</h4>
<pre>public&nbsp;TCPClient(java.nio.channels.SocketChannel&nbsp;channel)
          throws java.io.IOException</pre>
<div class="block"><p>This creates a TCPClient based off an already existing <code>SocketChannel</code>.  This <code>SocketChannel</code> must already be 
 connected.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>channel</code> - the <code>SocketChannel</code> to use for this client.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.io.IOException</code> - if there is anything wrong with the <code>SocketChannel</code> this will be thrown.</dd>
</dl>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="connect--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>connect</h4>
<pre>public&nbsp;org.threadly.concurrent.future.ListenableFuture&lt;java.lang.Boolean&gt;&nbsp;connect()</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="../../../../org/threadly/litesockets/Client.html#connect--">Client</a></code></span></div>
<div class="block"><p>Called to connect this client to a host.  This is done non-blocking, and can be called before adding the client 
 to the <a href="../../../../org/threadly/litesockets/SocketExecuterInterface.html" title="interface in org.threadly.litesockets"><code>SocketExecuterInterface</code></a>, but the client must be on the <a href="../../../../org/threadly/litesockets/SocketExecuterInterface.html" title="interface in org.threadly.litesockets"><code>SocketExecuterInterface</code></a> 
 in order to finish connecting.  If not called <a href="../../../../org/threadly/litesockets/SocketExecuterInterface.html#addClient-org.threadly.litesockets.Client-"><code>SocketExecuterInterface.addClient(Client)</code></a>
 will automatically call this.</p>
 
 <p>If there is an error connecting <a href="../../../../org/threadly/litesockets/Client.html#close--"><code>Client.close()</code></a> will also be called on the client.</p></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../../../org/threadly/litesockets/Client.html#connect--">connect</a></code>&nbsp;in class&nbsp;<code><a href="../../../../org/threadly/litesockets/Client.html" title="class in org.threadly.litesockets">Client</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <code>ListenableFuture</code> that will complete when the socket is connected, or fail if we cant connect.</dd>
</dl>
</li>
</ul>
<a name="hasConnectionTimedOut--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasConnectionTimedOut</h4>
<pre>public&nbsp;boolean&nbsp;hasConnectionTimedOut()</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="../../../../org/threadly/litesockets/Client.html#hasConnectionTimedOut--">Client</a></code></span></div>
<div class="block"><p>This tells us if the client has timed out before it has been connected to the socket.  This is used to remove the client
 from the selector when we have reached our timeout.  With nio there is no way to have it automatically 
 wake up the selector and time it out.  If the client has connected fully this will return false from that point on 
 (even on a closed connection).</p></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../../../org/threadly/litesockets/Client.html#hasConnectionTimedOut--">hasConnectionTimedOut</a></code>&nbsp;in class&nbsp;<code><a href="../../../../org/threadly/litesockets/Client.html" title="class in org.threadly.litesockets">Client</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>false if the client has been connected, true if it has not connected and the timeout limit has been reached.</dd>
</dl>
</li>
</ul>
<a name="getTimeout--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getTimeout</h4>
<pre>public&nbsp;int&nbsp;getTimeout()</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="../../../../org/threadly/litesockets/Client.html#getTimeout--">Client</a></code></span></div>
<div class="block"><p>Used to get this clients connection timeout information.</p></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../../../org/threadly/litesockets/Client.html#getTimeout--">getTimeout</a></code>&nbsp;in class&nbsp;<code><a href="../../../../org/threadly/litesockets/Client.html" title="class in org.threadly.litesockets">Client</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the max amount of time to wait for a connection to connect on this socket.</dd>
</dl>
</li>
</ul>
<a name="isClosed--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isClosed</h4>
<pre>public&nbsp;boolean&nbsp;isClosed()</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="../../../../org/threadly/litesockets/Client.html#isClosed--">Client</a></code></span></div>
<div class="block"><p>Returns if this client is closed or not.  Once a client is marked closed there is no way to reOpen it.
 You must just make a new client.  Just because this returns false does not mean the client is connected.
 Before a client connects, but has not yet closed this will be false.</p></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../../../org/threadly/litesockets/Client.html#isClosed--">isClosed</a></code>&nbsp;in class&nbsp;<code><a href="../../../../org/threadly/litesockets/Client.html" title="class in org.threadly.litesockets">Client</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>true if the client is closed, false if the client has not yet been closed.</dd>
</dl>
</li>
</ul>
<a name="close--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>close</h4>
<pre>public&nbsp;void&nbsp;close()</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="../../../../org/threadly/litesockets/Client.html#close--">Client</a></code></span></div>
<div class="block"><p>Closes this client.  Reads can still occur after this it called.  <a href="../../../../org/threadly/litesockets/Client.Closer.html#onClose-org.threadly.litesockets.Client-"><code>Client.Closer.onClose(Client)</code></a> will still be
 called (if set) once all reads are done.</p></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../../../org/threadly/litesockets/Client.html#close--">close</a></code>&nbsp;in class&nbsp;<code><a href="../../../../org/threadly/litesockets/Client.html" title="class in org.threadly.litesockets">Client</a></code></dd>
</dl>
</li>
</ul>
<a name="setReader-org.threadly.litesockets.Client.Reader-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setReader</h4>
<pre>public&nbsp;void&nbsp;setReader(<a href="../../../../org/threadly/litesockets/Client.Reader.html" title="interface in org.threadly.litesockets">Client.Reader</a>&nbsp;reader)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="../../../../org/threadly/litesockets/Client.html#setReader-org.threadly.litesockets.Client.Reader-">Client</a></code></span></div>
<div class="block"><p>This sets the Reader for the client.This should be set before adding the Client to the <a href="../../../../org/threadly/litesockets/SocketExecuterInterface.html" title="interface in org.threadly.litesockets"><code>SocketExecuterInterface</code></a>, 
 if its not there is a chance to miss data coming in on the socket.  Once set data received on the socket will be callback 
 on this Reader to be processed.</p></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../../../org/threadly/litesockets/Client.html#setReader-org.threadly.litesockets.Client.Reader-">setReader</a></code>&nbsp;in class&nbsp;<code><a href="../../../../org/threadly/litesockets/Client.html" title="class in org.threadly.litesockets">Client</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>reader</code> - the <a href="../../../../org/threadly/litesockets/Client.Reader.html" title="interface in org.threadly.litesockets"><code>Client.Reader</code></a> callback to set for this client.</dd>
</dl>
</li>
</ul>
<a name="getReader--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getReader</h4>
<pre>public&nbsp;<a href="../../../../org/threadly/litesockets/Client.Reader.html" title="interface in org.threadly.litesockets">Client.Reader</a>&nbsp;getReader()</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="../../../../org/threadly/litesockets/Client.html#getReader--">Client</a></code></span></div>
<div class="block"><p>Returns the currently set Reader callback. </p></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../../../org/threadly/litesockets/Client.html#getReader--">getReader</a></code>&nbsp;in class&nbsp;<code><a href="../../../../org/threadly/litesockets/Client.html" title="class in org.threadly.litesockets">Client</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the current <a href="../../../../org/threadly/litesockets/Client.Reader.html" title="interface in org.threadly.litesockets"><code>Client.Reader</code></a> callback for this client.</dd>
</dl>
</li>
</ul>
<a name="setCloser-org.threadly.litesockets.Client.Closer-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setCloser</h4>
<pre>public&nbsp;void&nbsp;setCloser(<a href="../../../../org/threadly/litesockets/Client.Closer.html" title="interface in org.threadly.litesockets">Client.Closer</a>&nbsp;closer)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="../../../../org/threadly/litesockets/Client.html#setCloser-org.threadly.litesockets.Client.Closer-">Client</a></code></span></div>
<div class="block"><p>This sets the <a href="../../../../org/threadly/litesockets/Client.Closer.html" title="interface in org.threadly.litesockets"><code>Client.Closer</code></a> interface for this client.  Once set the client will call .onClose 
 on it once it a socket close is detected.</p></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../../../org/threadly/litesockets/Client.html#setCloser-org.threadly.litesockets.Client.Closer-">setCloser</a></code>&nbsp;in class&nbsp;<code><a href="../../../../org/threadly/litesockets/Client.html" title="class in org.threadly.litesockets">Client</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>closer</code> - sets this clients <a href="../../../../org/threadly/litesockets/Client.Closer.html" title="interface in org.threadly.litesockets"><code>Client.Closer</code></a> callback.</dd>
</dl>
</li>
</ul>
<a name="getCloser--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getCloser</h4>
<pre>public&nbsp;<a href="../../../../org/threadly/litesockets/Client.Closer.html" title="interface in org.threadly.litesockets">Client.Closer</a>&nbsp;getCloser()</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="../../../../org/threadly/litesockets/Client.html#getCloser--">Client</a></code></span></div>
<div class="block"><p>This is used to get the currently set <a href="../../../../org/threadly/litesockets/Client.Closer.html" title="interface in org.threadly.litesockets"><code>Client.Closer</code></a> for this client.</p></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../../../org/threadly/litesockets/Client.html#getCloser--">getCloser</a></code>&nbsp;in class&nbsp;<code><a href="../../../../org/threadly/litesockets/Client.html" title="class in org.threadly.litesockets">Client</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the current <a href="../../../../org/threadly/litesockets/Client.Closer.html" title="interface in org.threadly.litesockets"><code>Client.Closer</code></a> interface for this client.</dd>
</dl>
</li>
</ul>
<a name="getProtocol--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getProtocol</h4>
<pre>public&nbsp;<a href="../../../../org/threadly/litesockets/SocketExecuterInterface.WireProtocol.html" title="enum in org.threadly.litesockets">SocketExecuterInterface.WireProtocol</a>&nbsp;getProtocol()</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="../../../../org/threadly/litesockets/Client.html#getProtocol--">Client</a></code></span></div>
<div class="block"><p>This is used by the <a href="../../../../org/threadly/litesockets/SocketExecuterInterface.html" title="interface in org.threadly.litesockets"><code>SocketExecuterInterface</code></a> to help understand how to manage this client.
 Currently only UDP and TCP exist.</p></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../../../org/threadly/litesockets/Client.html#getProtocol--">getProtocol</a></code>&nbsp;in class&nbsp;<code><a href="../../../../org/threadly/litesockets/Client.html" title="class in org.threadly.litesockets">Client</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The IP protocol type of this client.</dd>
</dl>
</li>
</ul>
<a name="getStats--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getStats</h4>
<pre>public&nbsp;<a href="../../../../org/threadly/litesockets/utils/SimpleByteStats.html" title="class in org.threadly.litesockets.utils">SimpleByteStats</a>&nbsp;getStats()</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="../../../../org/threadly/litesockets/Client.html#getStats--">Client</a></code></span></div>
<div class="block">Returns the <a href="../../../../org/threadly/litesockets/utils/SimpleByteStats.html" title="class in org.threadly.litesockets.utils"><code>SimpleByteStats</code></a> for this client.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../../../org/threadly/litesockets/Client.html#getStats--">getStats</a></code>&nbsp;in class&nbsp;<code><a href="../../../../org/threadly/litesockets/Client.html" title="class in org.threadly.litesockets">Client</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the byte stats for this client.</dd>
</dl>
</li>
</ul>
<a name="getReadBufferSize--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getReadBufferSize</h4>
<pre>public&nbsp;int&nbsp;getReadBufferSize()</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="../../../../org/threadly/litesockets/Client.html#getReadBufferSize--">Client</a></code></span></div>
<div class="block"><p>This is used to get the current size of the readBuffers pending reads.</p></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../../../org/threadly/litesockets/Client.html#getReadBufferSize--">getReadBufferSize</a></code>&nbsp;in class&nbsp;<code><a href="../../../../org/threadly/litesockets/Client.html" title="class in org.threadly.litesockets">Client</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the current size of the ReadBuffer.</dd>
</dl>
</li>
</ul>
<a name="getWriteBufferSize--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getWriteBufferSize</h4>
<pre>public&nbsp;int&nbsp;getWriteBufferSize()</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="../../../../org/threadly/litesockets/Client.html#getWriteBufferSize--">Client</a></code></span></div>
<div class="block"><p>This is used to get the current size of the unWriten writeBuffer.</p></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../../../org/threadly/litesockets/Client.html#getWriteBufferSize--">getWriteBufferSize</a></code>&nbsp;in class&nbsp;<code><a href="../../../../org/threadly/litesockets/Client.html" title="class in org.threadly.litesockets">Client</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the current size of the writeBuffer.</dd>
</dl>
</li>
</ul>
<a name="getMaxBufferSize--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMaxBufferSize</h4>
<pre>public&nbsp;int&nbsp;getMaxBufferSize()</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="../../../../org/threadly/litesockets/Client.html#getMaxBufferSize--">Client</a></code></span></div>
<div class="block">This is used to get the currently set max buffer size.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../../../org/threadly/litesockets/Client.html#getMaxBufferSize--">getMaxBufferSize</a></code>&nbsp;in class&nbsp;<code><a href="../../../../org/threadly/litesockets/Client.html" title="class in org.threadly.litesockets">Client</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the current MaxBuffer size allowed.  The read and write buffer use this independently.</dd>
</dl>
</li>
</ul>
<a name="getClientsThreadExecutor--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getClientsThreadExecutor</h4>
<pre>public&nbsp;java.util.concurrent.Executor&nbsp;getClientsThreadExecutor()</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="../../../../org/threadly/litesockets/Client.html#getClientsThreadExecutor--">Client</a></code></span></div>
<div class="block"><p> This returns this clients <code>Executor</code>.  The client must have been added to the <a href="../../../../org/threadly/litesockets/SocketExecuterInterface.html" title="interface in org.threadly.litesockets"><code>SocketExecuterInterface</code></a> or 
 this will return null.</p>
 
 <p> Its worth noting that operations done on this <code>Executor</code> can/will block Read callbacks on the 
 client, but it does provide you the ability to execute things on the clients read thread</p></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../../../org/threadly/litesockets/Client.html#getClientsThreadExecutor--">getClientsThreadExecutor</a></code>&nbsp;in class&nbsp;<code><a href="../../../../org/threadly/litesockets/Client.html" title="class in org.threadly.litesockets">Client</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The <code>Executor</code> for the client.</dd>
</dl>
</li>
</ul>
<a name="getClientsSocketExecuter--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getClientsSocketExecuter</h4>
<pre>public&nbsp;<a href="../../../../org/threadly/litesockets/SocketExecuterInterface.html" title="interface in org.threadly.litesockets">SocketExecuterInterface</a>&nbsp;getClientsSocketExecuter()</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="../../../../org/threadly/litesockets/Client.html#getClientsSocketExecuter--">Client</a></code></span></div>
<div class="block"><p>This is used to get the clients currently assigned <a href="../../../../org/threadly/litesockets/SocketExecuterInterface.html" title="interface in org.threadly.litesockets"><code>SocketExecuterInterface</code></a>.</p></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../../../org/threadly/litesockets/Client.html#getClientsSocketExecuter--">getClientsSocketExecuter</a></code>&nbsp;in class&nbsp;<code><a href="../../../../org/threadly/litesockets/Client.html" title="class in org.threadly.litesockets">Client</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the <a href="../../../../org/threadly/litesockets/SocketExecuterInterface.html" title="interface in org.threadly.litesockets"><code>SocketExecuterInterface</code></a> set for this client. if none, null is returned.</dd>
</dl>
</li>
</ul>
<a name="setMaxBufferSize-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setMaxBufferSize</h4>
<pre>public&nbsp;void&nbsp;setMaxBufferSize(int&nbsp;size)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="../../../../org/threadly/litesockets/Client.html#setMaxBufferSize-int-">Client</a></code></span></div>
<div class="block"><p>This allows you to set/change the max buffer size for this client object.
 This is the in java memory buffer not the additional socket buffer the OS might setup.</p>
 
 <p>In general this should be set to the max size you can deal with.  The lower this is the more often we
 will end up adding/removing the client from the selectors.  Both the read and write buffers are separate so 
 a client can use up to 2x the buffer size set here.  You need room in your heap for buffers for all clients.
 These buffers are not kept at full size, so clients will rarely use that much memory if the protocol parsing 
 and network are keeping up with the data going in/out.</p></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../../../org/threadly/litesockets/Client.html#setMaxBufferSize-int-">setMaxBufferSize</a></code>&nbsp;in class&nbsp;<code><a href="../../../../org/threadly/litesockets/Client.html" title="class in org.threadly.litesockets">Client</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>size</code> - max buffer size in bytes.</dd>
</dl>
</li>
</ul>
<a name="getRead--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRead</h4>
<pre>public&nbsp;<a href="../../../../org/threadly/litesockets/utils/MergedByteBuffers.html" title="class in org.threadly.litesockets.utils">MergedByteBuffers</a>&nbsp;getRead()</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="../../../../org/threadly/litesockets/Client.html#getRead--">Client</a></code></span></div>
<div class="block"><p>Whenever a the <a href="../../../../org/threadly/litesockets/Client.Reader.html" title="interface in org.threadly.litesockets"><code>Client.Reader</code></a> Interfaces <a href="../../../../org/threadly/litesockets/Client.Reader.html#onRead-org.threadly.litesockets.Client-"><code>Client.Reader.onRead(Client)</code></a> is called the
 <a href="../../../../org/threadly/litesockets/Client.html#getRead--"><code>Client.getRead()</code></a> should be called from the client.</p></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../../../org/threadly/litesockets/Client.html#getRead--">getRead</a></code>&nbsp;in class&nbsp;<code><a href="../../../../org/threadly/litesockets/Client.html" title="class in org.threadly.litesockets">Client</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="../../../../org/threadly/litesockets/utils/MergedByteBuffers.html" title="class in org.threadly.litesockets.utils"><code>MergedByteBuffers</code></a> of the current read data for this client.</dd>
</dl>
</li>
</ul>
<a name="writeTry-java.nio.ByteBuffer-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>writeTry</h4>
<pre>public&nbsp;boolean&nbsp;writeTry(java.nio.ByteBuffer&nbsp;bb)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="../../../../org/threadly/litesockets/Client.html#writeTry-java.nio.ByteBuffer-">Client</a></code></span></div>
<div class="block"><p> This tries to write the ByteBuffer passed to it to the Client.  If the Clients writeBuffer 
 is greater than the maxbufferSize the <code>ByteBuffer</code> will not be added and false will be returned.
 If the current writeBuffer is less than the maxBufferSize then the ByteBuffer will be added and this
 will return true.</p>
 
 <p>As this write is thread safe it should be noted that calling this with multiThreads can not garentee order.
 As such it is recommended to write full parsable protocol packets at a time, or implement your own locking around the
 write if you are streaming data raw data and using more then 1 thread to do such.
 </p></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../../../org/threadly/litesockets/Client.html#writeTry-java.nio.ByteBuffer-">writeTry</a></code>&nbsp;in class&nbsp;<code><a href="../../../../org/threadly/litesockets/Client.html" title="class in org.threadly.litesockets">Client</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>bb</code> - the <code>ByteBuffer</code> to write to the client.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>true if the client has taken the ByteBuffer false if it did not.</dd>
</dl>
</li>
</ul>
<a name="writeBlocking-java.nio.ByteBuffer-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>writeBlocking</h4>
<pre>public&nbsp;void&nbsp;writeBlocking(java.nio.ByteBuffer&nbsp;bb)
                   throws java.lang.InterruptedException</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="../../../../org/threadly/litesockets/Client.html#writeBlocking-java.nio.ByteBuffer-">Client</a></code></span></div>
<div class="block"><p>This write will block until the write can be done.  This block will only happen if the clients
 current writeBuffer size is more than the set maxBuffer.  This block will persist either until
 the clients writeBuffer is less than the maxWriteBuffer or the client is closed.</p>
 
 <p>Care should be taken when using this.  The pending writes for the client will happen on another unblockable 
 thread but if a lot of clients use there read thread to write and block its possible to consume all threads
 in the pool.  This is only a problem if the thread pool is reading/writing from both sides of a client connection
 using the same thread pool.</p>
 
 <p>As this write is thread safe it should be noted that calling this with multiThreads can not garentee order.
 As such it is recommended to write full parsable protocol packets at a time, or implement your own locking around the
 write if you are streaming data raw data and using more then 1 thread to do such.
 </p></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../../../org/threadly/litesockets/Client.html#writeBlocking-java.nio.ByteBuffer-">writeBlocking</a></code>&nbsp;in class&nbsp;<code><a href="../../../../org/threadly/litesockets/Client.html" title="class in org.threadly.litesockets">Client</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>bb</code> - the <code>ByteBuffer</code> to write.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.InterruptedException</code> - This happens only if the thread that is blocked is interrupted while waiting.</dd>
</dl>
</li>
</ul>
<a name="writeForce-java.nio.ByteBuffer-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>writeForce</h4>
<pre>public&nbsp;void&nbsp;writeForce(java.nio.ByteBuffer&nbsp;bb)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="../../../../org/threadly/litesockets/Client.html#writeForce-java.nio.ByteBuffer-">Client</a></code></span></div>
<div class="block"><p>This write forces the client to go over its maxBufferSize.  This can be dangerous if used incorrectly.
 Its assumed if this is used you are keeping track of the clients writeBuffer on your own.</p>
 
 <p>As this write is thread safe it should be noted that calling this with multiThreads can not garentee order.
 As such it is recommended to write full parsable protocol packets at a time, or implement your own locking around the
 write if you are streaming data raw data and using more then 1 thread to do such.
 </p></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../../../org/threadly/litesockets/Client.html#writeForce-java.nio.ByteBuffer-">writeForce</a></code>&nbsp;in class&nbsp;<code><a href="../../../../org/threadly/litesockets/Client.html" title="class in org.threadly.litesockets">Client</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>bb</code> - the ByteBuffer to write to the client.</dd>
</dl>
</li>
</ul>
<a name="getRemoteSocketAddress--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRemoteSocketAddress</h4>
<pre>public&nbsp;java.net.SocketAddress&nbsp;getRemoteSocketAddress()</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../../../org/threadly/litesockets/Client.html#getRemoteSocketAddress--">getRemoteSocketAddress</a></code>&nbsp;in class&nbsp;<code><a href="../../../../org/threadly/litesockets/Client.html" title="class in org.threadly.litesockets">Client</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the remote <code>SocketAddress</code> this client is connected to.</dd>
</dl>
</li>
</ul>
<a name="getLocalSocketAddress--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLocalSocketAddress</h4>
<pre>public&nbsp;java.net.SocketAddress&nbsp;getLocalSocketAddress()</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../../../org/threadly/litesockets/Client.html#getLocalSocketAddress--">getLocalSocketAddress</a></code>&nbsp;in class&nbsp;<code><a href="../../../../org/threadly/litesockets/Client.html" title="class in org.threadly.litesockets">Client</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the local <code>SocketAddress</code> this client is using.</dd>
</dl>
</li>
</ul>
<a name="toString--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>toString</h4>
<pre>public&nbsp;java.lang.String&nbsp;toString()</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code>toString</code>&nbsp;in class&nbsp;<code>java.lang.Object</code></dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../org/threadly/litesockets/tcp/SSLUtils.FullTrustManager.html" title="class in org.threadly.litesockets.tcp"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../../org/threadly/litesockets/tcp/TCPServer.html" title="class in org.threadly.litesockets.tcp"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?org/threadly/litesockets/tcp/TCPClient.html" target="_top">Frames</a></li>
<li><a href="TCPClient.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.classes.inherited.from.class.org.threadly.litesockets.Client">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
